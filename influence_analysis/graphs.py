import networkx as nx
from pathlib import Path
from typing import TypeAlias

SnapData: TypeAlias = dict[str, list[tuple[str, str]] | set[str]]

class GraphGenerator:
    @staticmethod
    def read_snap_txt(data_file: Path, separator: str = '\t') -> SnapData:
        """
        Reads the .txt file provided after unzipping the edges from the Stanford SNAP dataset
        :param data_file: Location of the .txt file
        :type data_file: Path
        :param separator: Separator between nodes in the text file.
        :type separator: str
        :return: Dictionary of nodes and edges
        :rtype: SnapData
        """
        edges = list()
        nodes = set()

        for line in data_file.read_text().splitlines():
            if line.startswith("#"): # Ignore any comments in the file
                continue
            from_node, to_node = line.split(separator)
            edges.append((from_node, to_node))
            nodes.add(from_node)
            nodes.add(to_node)

        return {
            "nodes": nodes,
            "edges": edges,
        }

    @staticmethod
    def get_graph(data: SnapData, directed: bool = False) -> nx.Graph:
        """
        Helper function to create a graph from the dataset
        :param data: Data generated by read_snap_txt()
        :type data: SnapData
        :param directed: Whether the generated graph is directed or undirected
        :type directed: bool
        :return: A NetworkX graph
        :rtype: nx.Graph
        """
        graph = nx.DiGraph() if directed else nx.Graph()
        graph.add_nodes_from(data["nodes"], active=False, already_spread=False)
        graph.add_edges_from(data["edges"])
        return graph

    @staticmethod
    def get_social_graph(data_file: Path = Path("data/social.txt"), separator: str = ' ') -> nx.Graph:
        data = GraphGenerator.read_snap_txt(data_file, separator=separator)
        return GraphGenerator.get_graph(data, directed=True)

    @staticmethod
    def get_collab_graph(data_file: Path = Path("/home/neusha/Courses/ECE227/ECE227/data/collab.txt"), separator: str = '\t') -> nx.Graph:
        data = GraphGenerator.read_snap_txt(data_file, separator=separator)
        return GraphGenerator.get_graph(data, directed=False)

    @staticmethod
    def get_comm_graph(data_file: Path = Path("data/comm.txt"), separator: str = '\t') -> nx.Graph:
        data = GraphGenerator.read_snap_txt(data_file, separator=separator)
        return GraphGenerator.get_graph(data, directed=False)
    
    @staticmethod
    def get_random_graph(num_nodes: int, p: float = 0.005, directed: bool = False) -> nx.Graph:
        """
        Generate a deterministic random graph based on number of nodes.
        Uses Erdos-Renyi model with a fixed seed for reproducibility.
        """
        seed = num_nodes
        if directed:
            graph = nx.gnp_random_graph(num_nodes, p, seed=seed, directed=True)
        else:
            graph = nx.gnp_random_graph(num_nodes, p, seed=seed, directed=False)
        nx.set_node_attributes(graph, False, "active")
        nx.set_node_attributes(graph, False, "already_spread")
        return graph

if __name__ == '__main__':
    social_graph = GraphGenerator.get_social_graph(Path("../data/social.txt"))
    collab_graph = GraphGenerator.get_collab_graph(Path("../data/collab.txt"))
    comm_graph = GraphGenerator.get_comm_graph(Path("../data/comm.txt"))

    def print_data(graph: nx.Graph) -> None:
        print(f"Number of nodes: {graph.number_of_nodes()}")
        print(f"Number of edges: {graph.number_of_edges()}")

    print("Social Network")
    print_data(social_graph)
    print()

    print("Collaborative Network")
    print_data(collab_graph)
    print()

    print("Community Network")
    print_data(comm_graph)
    print()